# frozen_string_literal: true

require "fileutils"
require "yaml"
require "middleman-core"
require "kramdown"
require "open3"
require "config"

namespace :tech_docs do
  desc "Build docs"
  task :build do
    # Build API docs
    TechDocsHelpers.build("api-docs")

    # Build CSV docs
    TechDocsHelpers.build("csv-docs")

    # Build Reference Data docs
    TechDocsHelpers.build("reference-data")

    # Generate search.json
    system("bundle exec middleman build")

    FileUtils.cp("build/search.json", "../public/api-docs")
    FileUtils.cp("build/search.json", "../public/csv-docs")
    FileUtils.cp("build/search.json", "../public/reference-data")
  end

  namespace :csv do
    desc "Generate CSV fields docs for all versions"
    task :generate do
      app     = Middleman::Application.new
      context = Middleman::TemplateContext.new(app, {})

      TechDocsHelpers.available_versions.each_with_index do |version, version_index|
        version_dir = TechDocsHelpers.format_version(version)
        fields = TechDocsHelpers.fields(version)

        FileUtils.mkdir_p("source/csv-docs/#{version_dir}")

        # Create version index with hide_in_navigation for v2026.0
        File.write("source/csv-docs/#{version_dir}/index.html.md", <<~METADATA)
          ---
          title: #{version_dir}
          weight: #{version_index + 3}
          hide_in_navigation: #{version_dir == 'v2026.0'}
          ---

          # #{version_dir}

        METADATA

        fields.each_with_index do |field, index|
          html = context.partial(
            "partials/csv_docs/field", locals: {
              csv_field_name: field["field_name"],
              column_number_in_csv_file: index,
              api_field_name: field["technical"],
              hesa_alignment: field["hesa_alignment"],
              description: Kramdown::Document.new(field["description"]).to_html,
              format: Kramdown::Document.new(field["format"]).to_html,
              example: Kramdown::Document.new(field["example"]).to_html,
              validation: Kramdown::Document.new(field["validation"]).to_html,
            }
          )

          File.open("source/csv-docs/#{version_dir}/#{field['technical'].gsub('_', '-')}.html.md", "w") do |f|
            f.write(
              <<~METADATA,
                ---
                title: #{field['field_name']}
                weight: #{index}
                source_url: https://github.com/DFE-Digital/register-trainee-teachers/blob/main/app/views/bulk_update/add_trainees/reference_docs/#{version_dir.tr('.', '_')}/fields.yaml
                ---

              METADATA
            )
            f.write(html)
          end
        end
      end
    end
  end

  namespace :reference_data do
    desc "Generate reference data docs from the API"
    task :generate do
      version_runner_code = "print Hesa::ReferenceData.constants"

      TechDocsHelpers.runner(version_runner_code).reject { |klass| %w[Base].include?(klass) }.reverse_each.with_index do |version, index|
        data_runner_code  = "print Hesa::ReferenceData::#{version}.all"
        version_dir       = TechDocsHelpers.format_version(version)

        FileUtils.mkdir_p("source/reference-data/#{version_dir}")

        File.write("source/reference-data/#{version_dir}/index.html.md.erb", <<~METADATA)
          ---
          title: #{version_dir}
          weight: #{index + 3}
          hide_in_navigation: #{version_dir == 'v2026.0'}
          ---

          # #{version_dir}

        METADATA

        app     = Middleman::Application.new
        context = Middleman::TemplateContext.new(app, {})

        fields = TechDocsHelpers.fields(version)

        data = TechDocsHelpers.runner(data_runner_code).sort_by do |attribute, _values|
          field_name = fields.detect { |field| field["technical"] == attribute }["field_name"].downcase
          words      = Regexp.union(TechDocsHelpers::WORDS_TO_NUMBERS.keys)
          field_name.gsub(words, TechDocsHelpers::WORDS_TO_NUMBERS)
        end.to_h

        data.each_with_index do |(attribute, values), index|
          field               = fields.detect { |field| field["technical"] == attribute }
          formatted_attribute = attribute.gsub("_", "-")

          File.open("source/reference-data/#{version_dir}/#{formatted_attribute}.html.md", "w") do |f|
            html = context.partial(
              "partials/reference_data/attribute", locals: {
                attribute: formatted_attribute,
                version: version_dir,
                field: field,
                values: values,
              }
            )

            f.write(
              <<~METADATA,
                ---
                title: #{field['page_title'] || field['field_name']}
                weight: #{index + 1}
                source_url: https://github.com/DFE-Digital/register-trainee-teachers/blob/main/app/lib/hesa/reference_data/#{version_dir.gsub(/(\.|-)/, '_')}.rb
                ---

              METADATA
            )

            f.write(html)
          end
        end
      end
    end

    desc "Generate reference data docs from the Register reference data YAML files"
    task :generate_from_yaml do
      # TODO: The version dir should not be hardcoded
      version_dir = "v2026-0"

      FileUtils.mkdir_p("source/reference-data/#{version_dir}")

      File.write("source/reference-data/#{version_dir}/index.html.md.erb", <<~METADATA)
        ---
        title: #{version_dir}
        weight: 3
        hide_in_navigation: #{version_dir == 'v2026.0' ? true : false }
        ---

        # #{version_dir}

      METADATA

      app = Middleman::Application.new
      context = Middleman::TemplateContext.new(app, {})

      ReferenceDataHelper.new.each_with_index do |reference_data_type, index|
        File.open("source/reference-data/#{version_dir}/#{reference_data_type.formatted_type_name}.html.md", "w+") do |f|
          html = context.partial(
            "partials/reference_data/attribute_from_yaml", locals: {
              version: version_dir,
              formatted_type_name: reference_data_type.formatted_type_name,
              type: reference_data_type.metadata,
              values: reference_data_type.type_values,
              index: index,
            }
          )

          f.write(
            <<~METADATA,
              ---
              title: #{reference_data_type.metadata.fetch("display_name")}
              weight: #{index + 1}
              source_url: https://github.com/DFE-Digital/register-trainee-teachers/blob/main/app/lib/hesa/reference_data/#{version_dir.gsub(/(\.|-)/, '_')}.rb
              ---

            METADATA
          )

          f.write(html)
        end
      end
    end
  end
end

module TechDocsHelpers
  RAILS_DIR     = File.expand_path("../", __dir__)
  RAILS_GEMFILE = File.join(RAILS_DIR, "Gemfile")
  WORDS_TO_NUMBERS = {
    "one" => 1,
    "two" => 2,
    "three" => 3,
    "four" => 4,
    "five" => 5,
    "six" => 6,
    "seven" => 7,
    "eight" => 8,
    "nine" => 9,
    "ten" => 10,
  }.freeze

  def self.runner(runner_code)
    command = <<~CMD
      cd #{RAILS_DIR} && BUNDLE_GEMFILE=#{RAILS_GEMFILE} bundle exec rails runner '#{runner_code}.to_json'
    CMD

    stdout, stderr, status = Open3.capture3(command)

    if status.success?
      JSON.parse(stdout)
    else
      raise(StandardError, stderr.presence || "Something went wrong")
    end
  end

  def self.fields(version)
    version_dir = version.to_s.downcase.insert(-2, "_") # V20250 -> v2025_0
    YAML.load_file(
      File.expand_path("../app/views/bulk_update/add_trainees/reference_docs/#{version_dir}/fields.yaml", __dir__),
    )
  end

  def self.available_versions
    Dir.glob(File.expand_path("../app/views/bulk_update/add_trainees/reference_docs/v*", __dir__))
       .map { |path| File.basename(path).tr("_", "").upcase } # v2025_0 -> V20250
       .sort
  end

  def self.format_version(version)
    if version =~ /^V(\d{4})(\d)([a-zA-Z]+)?$/
      major      = ::Regexp.last_match(1)
      minor      = ::Regexp.last_match(2)
      suffix     = ::Regexp.last_match(3)
      formatted  = "v#{major}.#{minor}"
      formatted += "-#{suffix}" if suffix
      formatted.downcase
    else
      raise("Invalid version format")
    end
  end

  def self.build(source)
    FileUtils.cp_r("source", "temp_source")

    FileUtils.rm("source/index.html.md")
    FileUtils.cp_r("source/#{source}/.", "source")
    FileUtils.rm_rf("source/api-docs")
    FileUtils.rm_rf("source/csv-docs")
    FileUtils.rm_rf("source/reference-data")

    system("bundle exec middleman build --build-dir ../public/#{source}")

    FileUtils.rm_rf("source")
    FileUtils.mv("temp_source", "source")
  end
end
<<<<<<< HEAD
=======

class ReferenceDataHelper
  include Enumerable

  ReferenceDataType = Struct.new(
    :metadata,
    :data,
    :formatted_type_name,
    :type_values,
  )

  ReferenceDataValue = Struct.new(
    :hesa_code,
    :id,
    :name,
    :display_name,
    :description,
    :start_year,
    :end_year,
  )

  def each
    hesa_value_labels = {}
    Dir["#{TechDocsHelpers::RAILS_DIR}/config/locales/reference_data/*.yml"].each do |file_path|
      labels = YAML.load_file(file_path, aliases: true)
      hesa_value_labels = hesa_value_labels.deep_merge(labels)
    end

    Dir["#{TechDocsHelpers::RAILS_DIR}/config/reference_data/*.yml"].each_with_index do |file_path, index|
      yaml = YAML.load_file(file_path)

      ReferenceDataType.new.tap do |reference_data_type|
        reference_data_type.metadata = yaml.fetch("metadata", {})
        reference_data_type.data = yaml.fetch("data", {})
        reference_data_type.formatted_type_name = reference_data_type.metadata.fetch("name").gsub("_", "-")
        reference_data_type.type_values = []

        reference_data_type.data.each do |value|
          hesa_codes = value.fetch("hesa_codes", [])
          if hesa_codes.present?
            hesa_codes.each do |code|
              reference_data_type.type_values << ReferenceDataValue.new(
                hesa_code: code,
                id: value.fetch("id"),
                name: value.fetch("name"),
                display_name: hesa_value_labels.dig("en", reference_data_type.metadata.fetch("name"), code) || value.fetch("display_name"),
                description: value.fetch("description", nil),
                start_year: value.fetch("start_year", nil),
                end_year: value.fetch("end_year", nil),
              )
            end
          else
            reference_data_type.type_values << ReferenceDataValue.new(
              hesa_code: "-",
              id: value.fetch("id"),
              name: value.fetch("name"),
              display_name: value.fetch("display_name"),
              description: value.fetch("description", nil),
              start_year: value.fetch("start_year", nil),
              end_year: value.fetch("end_year", nil),
            )
          end
        end

        yield(reference_data_type)
      end
    end
  end
end
>>>>>>> c796f8cca (WIP)
